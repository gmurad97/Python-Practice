# Пример 1: Побитовое исключающее ИЛИ (XOR)
a = 5 ^ 2  # 5 = 0101, 2 = 0010, 5 XOR 2 = 0111
# Операция XOR возвращает 1, если биты в соответствующих позициях разные, иначе 0.
print("5 ^ 2 =", a)  # Результат: 7

# Пример 2: Побитовое И (AND)
a = 5 & 3  # 5 = 0101, 3 = 0011, 5 AND 3 = 0001
# Операция AND возвращает 1, если оба бита на данной позиции равны 1.
print("5 & 3 =", a)  # Результат: 1

# Пример 3: Побитовое ИЛИ (OR)
a = 5 | 3  # 5 = 0101, 3 = 0011, 5 OR 3 = 0111
# Операция OR возвращает 1, если хотя бы один из битов на данной позиции равен 1.
print("5 | 3 =", a)  # Результат: 7

# Пример 4: Побитовый сдвиг влево (<<)
a = 5 << 1  # 5 = 0101, сдвигаем влево на 1: 1010 = 10
# Операция сдвига влево удваивает число для каждого сдвига на 1 бит.
print("5 << 1 =", a)  # Результат: 10

# Пример 5: Побитовый сдвиг вправо (>>)
a = 5 >> 1  # 5 = 0101, сдвигаем вправо на 1: 0010 = 2
# Операция сдвига вправо делит число на 2 для каждого сдвига на 1 бит.
print("5 >> 1 =", a)  # Результат: 2

# Пример 6: Побитовая инверсия (~)
a = ~5  # 5 = 0101, инвертируем биты: ~0101 = 1010 (в дополнительном коде)
# Побитовая инверсия меняет все биты на противоположные. Также важно помнить, что Python использует дополнительный код для представления отрицательных чисел.
print("~5 =", a)  # Результат: -6, т.к. в Python отрицательные числа представлены в дополнительном коде

# Пример 7: Проверка побитового сдвига (для понимания работы сдвигов)
a = 1 << 3  # Сдвигаем 1 на 3 позиции влево, результат: 1000 = 8
print("1 << 3 =", a)  # Результат: 8

a = 8 >> 2  # Сдвигаем 8 на 2 позиции вправо, результат: 10 = 2
print("8 >> 2 =", a)  # Результат: 2
